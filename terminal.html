<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEXUS: Digital Infiltration</title>
    <style>
        /* Reset default styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Body and global styles */
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #00ff00;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Bootloader screen */
        #bootloader-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: #00ff00;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            font-size: 1.2em;
            animation: flicker 0.5s infinite;
        }

        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        /* Main game container */
        #game-container {
            display: flex;
            flex: 1;
            padding: 10px;
        }

        /* Terminal area */
        #terminal-container {
            flex: 2;
            background: #111;
            border: 2px solid #00ff00;
            border-radius: 5px;
            padding: 10px;
            margin-right: 10px;
            display: flex;
            flex-direction: column;
            position: relative;
            height: 100%;
        }

        #terminal-output {
            flex: 1;
            overflow-y: auto;
            font-size: 0.9em;
            padding-right: 10px;
            max-height: calc(100vh - 150px);
        }

        .terminal-line {
            margin-bottom: 5px;
            white-space: pre-wrap;
        }

        #terminal-input {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }

        #prompt-span {
            color: #00ff00;
            margin-right: 5px;
        }

        #command-input {
            background: transparent;
            border: none;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            flex: 1;
            outline: none;
        }

        #command-input:disabled {
            color: #666;
        }

        /* Sidebar */
        #sidebar {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #stats-panel, #targets-panel, #tools-panel {
            background: #111;
            border: 2px solid #00ff00;
            border-radius: 5px;
            padding: 10px;
            font-size: 0.9em;
        }

        #stats-panel {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        #trace-bar-container {
            background: #333;
            height: 20px;
            border: 1px solid #00ff00;
            border-radius: 3px;
            overflow: hidden;
        }

        #trace-bar {
            background: #ff0000;
            height: 100%;
            width: 0;
            transition: width 0.3s;
        }

        #breachAlert {
            display: none;
            color: #ff0000;
            font-weight: bold;
            text-align: center;
            animation: blink 0.5s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        #target-list, #tools-list {
            list-style: none;
        }

        .target-item, .tool-item {
            padding: 5px;
            margin-bottom: 5px;
            background: #222;
            border-radius: 3px;
            cursor: pointer;
        }

        .target-item:hover, .tool-item:hover {
            background: #333;
        }

        .target-name {
            font-weight: bold;
        }

        .target-difficulty {
            font-size: 0.8em;
            color: #00cc00;
        }

        /* Minigame overlay */
        #minigame-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            justify-content: center;
            align-items: center;
            z-index: 999;
        }

        #minigame-content {
            background: #111;
            border: 2px solid #00ff00;
            border-radius: 5px;
            padding: 20px;
            max-width: 600px;
            text-align: center;
        }

        .password-challenge {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .puzzle-visual {
            font-size: 1.2em;
            color: #00ff00;
        }

        .cipher-text {
            letter-spacing: 5px;
        }

        .password-hint {
            font-size: 0.9em;
            color: #00cc00;
        }

        .password-input {
            background: #222;
            border: 1px solid #00ff00;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            padding: 5px;
            font-size: 0.9em;
            text-align: center;
        }

        .keypad-visual {
            display: grid;
            grid-template-columns: repeat(3, 50px);
            gap: 5px;
            justify-content: center;
            margin: 10px 0;
        }

        .key {
            background: #222;
            border: 1px solid #00ff00;
            color: #00ff00;
            padding: 10px;
            text-align: center;
            cursor: pointer;
        }

        .key:hover {
            background: #333;
        }

        .key.highlight {
            background: #00ff00;
            color: #000;
        }

        .btn, .closeBtn {
            background: #222;
            border: 1px solid #00ff00;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            padding: 5px 10px;
            cursor: pointer;
            margin: 5px;
        }

        .btn:hover, .closeBtn:hover {
            background: #333;
        }

        /* Easter egg visual effects */
        .matrix-mode {
            background: #000;
            position: relative;
        }

        .matrix-mode::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, transparent, #000);
            z-index: -1;
            animation: matrix-rain 0.5s linear infinite;
        }

        @keyframes matrix-rain {
            0% { background-position: 0 0; }
            100% { background-position: 0 100%; }
        }

        .monochrome-mode {
            filter: grayscale(100%);
            background: #111;
        }

        .tron-mode {
            background: #000;
            color: #00b7eb;
            border-color: #00b7eb;
        }

        .tron-mode #trace-bar {
            background: #00b7eb;
        }

        .tron-mode .target-item, .tron-mode .tool-item {
            border-color: #00b7eb;
        }

        .inferno-mode {
            background: #220000;
            color: #ff4500;
            border-color: #ff4500;
        }

        .inferno-mode #trace-bar {
            background: #ff4500;
        }

        .inferno-mode .target-item, .inferno-mode .tool-item {
            border-color: #ff4500;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #111;
        }

        ::-webkit-scrollbar-thumb {
            background: #00ff00;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #00cc00;
        }

        /* Scroll button styling */
        .scroll-btn {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: #222;
            border: 1px solid #00ff00;
            color: #00ff00;
            padding: 5px 10px;
            cursor: pointer;
            z-index: 10;
        }

        .scroll-btn:hover {
            background: #333;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            #game-container {
                flex-direction: column;
            }
            #terminal-container, #sidebar {
                margin: 0;
                margin-bottom: 10px;
            }
            #sidebar {
                flex: none;
            }
        }
    </style>
</head>
<body>
    <div id="bootloader-screen">
        <pre id="bootloader-text">
NEXUS v2.1 SYSTEM BOOT
███████╗███╗   ██╗███████╗██╗   ██╗██╗   ██╗███████╗
██╔════╝████╗  ██║██╔════╝██║   ██║██║   ██║██╔════╝
█████╗  ██╔██╗ ██║█████╗  ██║   ██║██║   ██║█████╗  
██╔══╝  ██║╚██╗██║██╔══╝  ██║   ██║██║   ██║██╔══╝  
███████╗██║ ╚████║███████╗╚██████╔╝╚██████╔╝███████╗
╚══════╝╚═╝  ╚═══╝╚══════╝ ╚═════╝  ╚═════╝ ╚══════╝
> INITIATING SECURE BOOT...
> BIOS AUTH OK
> ENCRYPTED TRACE SYSTEM READY
> SAFEHOUSE ENCRYPTION SYNCED
> LOADING TERMINAL INTERFACE . . .
        </pre>
    </div>
    <div id="breachAlert" role="alert">SECURITY BREACH DETECTED</div>
    <div id="game-container">
        <div id="terminal-container">
            <div id="terminal-output" role="log" aria-live="polite">
                <div class="terminal-line">> NEXUS NETWORK ACCESS GRANTED</div>
                <div class="terminal-line">> Welcome to the underground, hacker.</div>
                <div class="terminal-line">> Your reputation precedes you...</div>
                <div class="terminal-line">> Available targets are listed on your right.</div>
                <div class="terminal-line">> Choose wisely. Every hack leaves a trace.</div>
                <div class="terminal-line">> Type 'help' for available commands.</div>
                <div class="terminal-line">> Type 'tutorial' to start the tutorial.</div>
                <div class="terminal-line">></div>
            </div>
            <div id="terminal-input">
                <span id="prompt-span">root@nexus:~$</span>
                <input type="text" id="command-input" placeholder="Enter command..." autocomplete="off" aria-label="Terminal command input">
            </div>
            <button class="scroll-btn" id="scroll-btn" title="Scroll to bottom" aria-label="Scroll to bottom of terminal">↓</button>
        </div>
        <div id="sidebar">
            <div id="stats-panel">
                <div class="stat">
                    <span>TRACE</span>
                    <div id="trace-bar-container">
                        <div id="trace-bar"></div>
                    </div>
                </div>
                <div class="stat">
                    <span>REP</span>
                    <span id="reputation">0</span>
                </div>
                <div class="stat">
                    <span>CREDITS</span>
                    <span id="credits">100</span>
                </div>
                <div class="stat">
                    <span>RANK</span>
                    <span id="rank">Script Kiddie</span>
                </div>
            </div>
            <div id="targets-panel">
                <div class="section-title">Available Targets</div>
                <ul id="target-list">
                    <li class="target-item" data-target="gameserver">
                        <div class="target-name">RetroArcade Server</div>
                        <div class="target-difficulty">Difficulty: Easy | Reward: 50 Credits</div>
                    </li>
                    <li class="target-item" data-target="socialnet">
                        <div class="target-name">SocialNet Database</div>
                        <div class="target-difficulty">Difficulty: Medium | Reward: 150 Credits</div>
                    </li>
                    <li class="target-item" data-target="corpnet">
                        <div class="target-name">CorpNet Mainframe</div>
                        <div class="target-difficulty">Difficulty: Hard | Reward: 300 Credits</div>
                    </li>
                    <li class="target-item" data-target="quantum">
                        <div class="target-name">Quantum Research Lab</div>
                        <div class="target-difficulty">Difficulty: Expert | Reward: 500 Credits</div>
                    </li>
                    <li class="target-item" data-target="ai_core">
                        <div class="target-name">AI Core Network</div>
                        <div class="target-difficulty">Difficulty: Master | Reward: 1000 Credits</div>
                    </li>
                </ul>
            </div>
            <div id="tools-panel">
                <div class="section-title">Your Tools</div>
                <ul id="tools-list">
                    <li class="tool-item">Basic Scanner (Lv1)</li>
                    <li class="tool-item">Password Cracker (Lv1)</li>
                    <li class="tool-item">Trace Cleaner (Lv1)</li>
                </ul>
            </div>
        </div>
    </div>
    <div id="minigame-overlay">
        <div id="minigame-content">
            <div class="minigame-title" id="minigame-title">SECURITY BREACH</div>
            <!-- Example keypad structure for corpnet minigame -->
            <div class="keypad-visual" id="keypad" style="display: none;">
                <div class="key" data-value="1" role="button" aria-label="Key 1" tabindex="0">1</div>
                <div class="key" data-value="2" role="button" aria-label="Key 2" tabindex="0">2</div>
                <div class="key" data-value="3" role="button" aria-label="Key 3" tabindex="0">3</div>
                <div class="key" data-value="4" role="button" aria-label="Key 4" tabindex="0">4</div>
                <div class="key" data-value="5" role="button" aria-label="Key 5" tabindex="0">5</div>
                <div class="key" data-value="6" role="button" aria-label="Key 6" tabindex="0">6</div>
                <div class="key" data-value="7" role="button" aria-label="Key 7" tabindex="0">7</div>
                <div class="key" data-value="8" role="button" aria-label="Key 8" tabindex="0">8</div>
                <div class="key" data-value="9" role="button" aria-label="Key 9" tabindex="0">9</div>
            </div>
        </div>
    </div>
    <script>
// Get DOM elements
const terminalOutput = document.getElementById('terminal-output');
const commandInput = document.getElementById('command-input');
const minigameOverlay = document.getElementById('minigame-overlay');
const creditsDisplay = document.getElementById('credits');
const reputationDisplay = document.getElementById('reputation');
const traceBar = document.getElementById('trace-bar');
const rankDisplay = document.getElementById('rank');
const promptSpan = document.getElementById('prompt-span');
const bootScreen = document.getElementById('bootloader-screen');
const breachAlert = document.getElementById('breachAlert');
const scrollBtn = document.getElementById('scroll-btn');

// Initialize game state
let gameState = {
    credits: 100,
    reputation: 0,
    traceLevel: 0,
    heat: 0,
    level: 1,
    xp: 0,
    tools: { scanner: 1, cracker: 1, cleaner: 1 },
    upgrades: { scanner: 1, cracker: 1, cleaner: 1 },
    discoveredTargets: ['gameserver', 'socialnet', 'corpnet', 'quantum', 'ai_core'],
    lastSave: Date.now(),
    commandHistory: [],
    historyIndex: -1,
    customPrompt: 'root@nexus:~$ ',
    safehouse: { scannerRoom: 0, firewallLab: 0, cryptoMiner: 0 },
    cryptoHoldings: { bitghost: 0, zerocoin: 0 },
    factions: {
        phreakers: { reputation: 0, missions: [] },
        cryptos: { reputation: 0, missions: [] },
        anarchists: { reputation: 0, missions: [] }
    },
    team: { hackers: [], mercenaries: [] },
    achievements: [],
    easterEggs: { matrix: false, monochrome: false, tron: false, inferno: false },
    wanted: false,
    isBreached: false,
    commandEntered: false,
    currentTarget: null,
    cryptoMinerTimer: null
};

// Load saved game
function loadGame() {
    try {
        if (gameState.safehouse.cryptoMinerTimer) {
            clearInterval(gameState.safehouse.cryptoMinerTimer);
        }
        const savedGameData = localStorage.getItem('nexusSave');
        if (savedGameData) {
            const parsedData = JSON.parse(savedGameData);
            // Ensure all required properties exist
            gameState = {
                ...gameState,
                ...parsedData,
                // Ensure these properties are always initialized
                tools: { ...gameState.tools, ...parsedData.tools },
                safehouse: { ...gameState.safehouse, ...parsedData.safehouse },
                cryptoHoldings: { ...gameState.cryptoHoldings, ...parsedData.cryptoHoldings },
                factions: { ...gameState.factions, ...parsedData.factions },
                team: { ...gameState.team, ...parsedData.team },
                easterEggs: { ...gameState.easterEggs, ...parsedData.easterEggs }
            };
            addTerminalLine('> Save file loaded successfully.');
            setupCryptoMiner();
        }
    } catch (e) {
        console.error('Error loading game:', e);
        addTerminalLine('> Error: Failed to load save file. Starting new game.');
        // Reset game state to default
        gameState = { ...gameState };
    }
    updateDisplay();
}

// Hide bootloader and initialize
setTimeout(() => {
    bootScreen.style.display = 'none';
    addTerminalLine('> Welcome back, operator.');
    addTerminalLine('> NEXUS interface fully loaded.');
    loadGame();
    commandInput.focus();
}, 3000);

// Core utility functions
function addTerminalLine(text) {
    const line = document.createElement('div');
    line.className = 'terminal-line';
    line.textContent = text;
    terminalOutput.appendChild(line);
    scrollToBottom();
}

function scrollToBottom() {
    terminalOutput.scrollTop = terminalOutput.scrollHeight;
}

function updateDisplay() {
    creditsDisplay.textContent = Math.floor(gameState.credits);
    reputationDisplay.textContent = gameState.reputation;
    traceBar.style.width = `${Math.min(100, gameState.traceLevel)}%`;
    const rankElement = document.getElementById('rank');
    if (rankElement) {
        rankElement.textContent = determineRank(gameState.reputation);
    }
    promptSpan.textContent = gameState.customPrompt;
    
    if (gameState.traceLevel >= 100 && !gameState.isBreached) {
        gameState.isBreached = true;
        breachAlert.style.display = 'block';
        addTerminalLine('> WARNING: SECURITY BREACH DETECTED! Use "clean" to clear trace.');
    } else if (gameState.traceLevel < 100 && gameState.isBreached) {
        gameState.isBreached = false;
        breachAlert.style.display = 'none';
    }
}

function determineRank(reputation) {
    if (reputation >= 1000) return 'Hackerman';
    if (reputation >= 500) return 'Master';
    if (reputation >= 200) return 'Expert';
    if (reputation >= 100) return 'Advanced';
    if (reputation >= 50) return 'Intermediate';
    return 'Script Kiddie';
}

// Available targets
const targets = {
    gameserver: {
        name: 'RetroArcade Server',
        difficulty: 'Easy',
        reward: 50,
        password: 'level1',
        pattern: 'L_V_L1',
        hint: 'Pattern: L_V_L1 (Fill in the missing letters)'
    },
    socialnet: {
        name: 'SocialNet Database', 
        difficulty: 'Medium',
        reward: 150,
        password: 'unlock',
        cipher: 'VOMPEG',
        hint: 'Caesar Cipher +6: VOMPEG → ?'
    },
    corpnet: {
        name: 'CorpNet Mainframe',
        difficulty: 'Hard', 
        reward: 300,
        password: 'matrix',
        sequence: '4-1-7-9-9-6',
        hint: 'Number sequence on keypad spells: 4-1-7-9-9-6'
    },
    quantum: {
        name: 'Quantum Research Lab',
        difficulty: 'Expert',
        reward: 500,
        password: 'entangled',
        puzzle: 'quantum',
        hint: 'Solve the quantum entanglement puzzle (flip qubits to match "entangled")'
    },
    ai_core: {
        name: 'AI Core Network',
        difficulty: 'Master',
        reward: 1000,
        password: 'singularity',
        puzzle: 'binary',
        hint: 'Synchronize with binary stream to match: singularity'
    }
};

// Black market items
const blackMarketItems = {
    tools: {
        'Quantum Decryptor': { cost: 2000, effect: 'cracker', bonus: 0.3 },
        'Stealth Module': { cost: 1500, effect: 'cleaner', bonus: 0.4 },
        'Advanced Scanner': { cost: 1800, effect: 'scanner', bonus: 0.25 }
    },
    mercenaries: {
        'Script Kiddie': { 
            cost: 200, skill: 'cracker', bonus: 0.1, level: 'Beginner', description: 'Basic password cracking skills', specialties: ['Simple Passwords', 'Basic Encryption']
        },
        'Net Runner': { 
            cost: 300, skill: 'scanner', bonus: 0.15, level: 'Beginner', description: 'Network scanning specialist', specialties: ['Port Scanning', 'Basic Recon']
        },
        'Ghost Byte': { 
            cost: 250, skill: 'cleaner', bonus: 0.12, level: 'Beginner', description: 'Entry-level trace cleaner', specialties: ['Basic Log Removal', 'Simple Traces']
        },
        'Cipher Master': { 
            cost: 800, skill: 'cracker', bonus: 0.25, level: 'Intermediate', description: 'Advanced encryption specialist', specialties: ['Complex Passwords', 'Custom Encryption']
        },
        'Network Phantom': { 
            cost: 1000, skill: 'scanner', bonus: 0.3, level: 'Intermediate', description: 'Advanced network penetration expert', specialties: ['Vulnerability Scanning', 'Network Mapping']
        },
        'Trace Eraser': { 
            cost: 900, skill: 'cleaner', bonus: 0.28, level: 'Intermediate', description: 'Advanced trace removal specialist', specialties: ['Deep Clean', 'Pattern Erasure']
        },
        'Quantum Breaker': { 
            cost: 2000, skill: 'cracker', bonus: 0.4, level: 'Expert', description: 'Quantum encryption specialist', specialties: ['Quantum Encryption', 'Advanced Algorithms']
        },
        'System Ghost': { 
            cost: 2500, skill: 'scanner', bonus: 0.45, level: 'Expert', description: 'Advanced system penetration expert', specialties: ['Zero-Day Exploits', 'Advanced Recon']
        },
        'Shadow Walker': { 
            cost: 2200, skill: 'cleaner', bonus: 0.42, level: 'Expert', description: 'Master of digital stealth', specialties: ['Complete Erasure', 'Pattern Rewriting']
        },
        'Neural Net': { 
            cost: 5000, skill: 'cracker', bonus: 0.6, level: 'Master', description: 'AI-powered cracking specialist', specialties: ['Neural Networks', 'Adaptive Cracking']
        },
        'Quantum Phantom': { 
            cost: 6000, skill: 'scanner', bonus: 0.65, level: 'Master', description: 'Quantum computing expert', specialties: ['Quantum Scanning', 'Reality Bending']
        },
        'Void Walker': { 
            cost: 5500, skill: 'cleaner', bonus: 0.62, level: 'Master', description: 'Master of digital void', specialties: ['Reality Rewriting', 'Time Manipulation']
        }
    }
};

// Faction missions
const factionMissions = {
    phreakers: [
        { id: 'p1', title: 'Phone Network Infiltration', reward: 300, heat: 20, difficulty: 'Medium' },
        { id: 'p2', title: 'Satellite Access', reward: 500, heat: 30, difficulty: 'Hard' }
    ],
    cryptos: [
        { id: 'c1', title: 'Blockchain Analysis', reward: 400, heat: 15, difficulty: 'Medium' },
        { id: 'c2', title: 'Crypto Exchange Hack', reward: 600, heat: 25, difficulty: 'Hard' }
    ],
    anarchists: [
        { id: 'a1', title: 'Government Database', reward: 800, heat: 40, difficulty: 'Expert' },
        { id: 'a2', title: 'Corporate Secrets', reward: 1000, heat: 35, difficulty: 'Master' }
    ]
};

// Safehouse upgrades
const safehouseUpgrades = {
    scannerRoom: {
        name: 'Enhanced Scanner Room',
        levels: [
            { cost: 100, effect: 'Increases scan speed by 10%', bonus: 0.1 },
            { cost: 300, effect: 'Increases scan speed by 20%', bonus: 0.2 },
            { cost: 600, effect: 'Increases scan speed by 30%', bonus: 0.3 }
        ]
    },
    firewallLab: {
        name: 'Advanced Firewall Lab',
        levels: [
            { cost: 150, effect: 'Reduces trace gain by 5%', bonus: 0.05 },
            { cost: 400, effect: 'Reduces trace gain by 10%', bonus: 0.1 },
            { cost: 800, effect: 'Reduces trace gain by 15%', bonus: 0.15 }
        ]
    },
    cryptoMiner: {
        name: 'Crypto Miner Rig',
        levels: [
            { cost: 200, effect: 'Generates 1 credit every 30 seconds', interval: 30000, amount: 1 },
            { cost: 500, effect: 'Generates 3 credits every 30 seconds', interval: 30000, amount: 3 },
            { cost: 1000, effect: 'Generates 7 credits every 30 seconds', interval: 30000, amount: 7 }
        ]
    }
};

// Crypto market prices
const cryptoMarketPrices = {
    bitghost: 50,
    zerocoin: 120
};

// Fluctuate crypto prices
function fluctuateCryptoPrices() {
    const volatility = 0.1;
    Object.keys(cryptoMarketPrices).forEach(crypto => {
        const currentPrice = cryptoMarketPrices[crypto];
        const changePercent = (Math.random() * volatility * 2 - volatility);
        cryptoMarketPrices[crypto] = Math.max(5, Math.round(currentPrice + currentPrice * changePercent));
    });
}
setInterval(fluctuateCryptoPrices, 5 * 60 * 1000);
fluctuateCryptoPrices();

// Setup crypto miner
function setupCryptoMiner() {
    if (gameState.safehouse.cryptoMinerTimer) {
        clearInterval(gameState.safehouse.cryptoMinerTimer);
    }
    const level = gameState.safehouse.cryptoMiner;
    if (level > 0) {
        const miner = safehouseUpgrades.cryptoMiner.levels[level - 1];
        if (miner) {
            gameState.safehouse.cryptoMinerTimer = setInterval(() => {
                gameState.credits += miner.amount;
                updateDisplay();
            }, miner.interval);
        }
    }
}

// Available commands
const commands = {
    help: {
        execute: () => {
            addTerminalLine('=== AVAILABLE COMMANDS ===');
            addTerminalLine('\n=== CORE COMMANDS ===');
            addTerminalLine('scan [target] - Scan a target system');
            addTerminalLine('hack [target] - Attempt to hack a system');
            addTerminalLine('clean - Clear trace level');
            addTerminalLine('status - Show current status');
            addTerminalLine('targets - List available targets');
            addTerminalLine('clear - Clear terminal output');
            addTerminalLine('\n=== TEAM MANAGEMENT ===');
            addTerminalLine('hire [hacker|mercenary] [name] - Hire a new team member');
            addTerminalLine('team - View your current team');
            addTerminalLine('list [hackers|mercenaries] - View available personnel');
            addTerminalLine('fire [hacker|mercenary] [name] - Remove a team member');
            addTerminalLine('\n=== UPGRADES & SHOPPING ===');
            addTerminalLine('upgrade [tool] - Upgrade a specific tool');
            addTerminalLine('shop - View available upgrades');
            addTerminalLine('blackmarket - Access the black market');
            addTerminalLine('buy [item] - Purchase an item from black market');
            addTerminalLine('\n=== SAFEHOUSE ===');
            addTerminalLine('safehouse - View your safehouse status and upgrades');
            addTerminalLine('upgrade_safehouse [upgrade_name] - Upgrade your safehouse');
            addTerminalLine('\n=== FACTION SYSTEM ===');
            addTerminalLine('factions - View faction status');
            addTerminalLine('mission [faction] - View available missions');
            addTerminalLine('accept [mission_id] - Accept a faction mission');
            addTerminalLine('\n=== HEAT & SECURITY ===');
            addTerminalLine('heat - View current heat level');
            addTerminalLine('\n=== ACHIEVEMENTS & EASTER EGGS ===');
            addTerminalLine('achievements - View unlocked achievements');
            addTerminalLine('matrix - Toggle Matrix-style visual effects');
            addTerminalLine('monochrome - Toggle Monochrome visual effects');
            addTerminalLine('tron - Toggle Tron-style visual effects');
            addTerminalLine('inferno - Toggle Inferno visual effects');
            addTerminalLine('hackerman - Special command for high-reputation players');
            addTerminalLine('\n=== SAVE SYSTEM ===');
            addTerminalLine('save - Save current game state');
            addTerminalLine('load - Load last saved game state');
            addTerminalLine('\n=== CRYPTO MARKET ===');
            addTerminalLine('crypto - View crypto market prices and your holdings');
            addTerminalLine('buy_crypto [currency] [amount] - Buy cryptocurrency');
            addTerminalLine('sell_crypto [currency] [amount] - Sell cryptocurrency');
            addTerminalLine('\n=== CUSTOMIZATION ===');
            addTerminalLine('set_prompt [prompt] - Set custom terminal prompt');
            enableInput();
        },
        description: 'Show available commands'
    },
    scan: {
        execute: (targetName) => {
            if (!targetName) {
                addTerminalLine('Usage: scan [target_name]');
                enableInput();
                return;
            }
            const targetKey = findTargetKeyByName(targetName);
            if (targetKey && targets[targetKey]) {
                const target = targets[targetKey];
                let scanTrace = { Easy: 5, Medium: 10, Hard: 15, Expert: 20, Master: 25 }[target.difficulty];
                scanTrace = Math.max(2, scanTrace * (1 - 0.1 * gameState.tools.scanner) * (1 - gameState.safehouse.firewallLab * 0.05));
                gameState.traceLevel += scanTrace;
                addTerminalLine(`> Scanning ${target.name}...`);
                setTimeout(() => {
                    addTerminalLine(`> Security Level: ${target.difficulty}`);
                    addTerminalLine(`> Potential Reward: ${target.reward} credits`);
                    addTerminalLine(`> Trace +${Math.round(scanTrace)}`);
                    addTerminalLine('> Scan complete. Ready for infiltration.');
                    updateDisplay();
                    saveGame();
                    enableInput();
                }, 1000 * (1 - 0.1 * gameState.safehouse.scannerRoom));
            } else {
                addTerminalLine('> Target not found.');
                enableInput();
            }
        },
        description: 'Scan a target system by its full name'
    },
    hack: {
        execute: (targetName) => {
            if (!targetName) {
                addTerminalLine('Usage: hack [target_name]');
                enableInput();
                return;
            }
            const targetKey = findTargetKeyByName(targetName);
            if (targetKey && targets[targetKey]) {
                addTerminalLine(`> Initiating hack on ${targets[targetKey].name}...`);
                gameState.currentTarget = targetKey;
                setTimeout(() => startMinigame(targetKey), 500);
            } else {
                addTerminalLine('> Target not found.');
                enableInput();
            }
        },
        description: 'Attempt to hack a system by its full name'
    },
    clean: {
        execute: () => {
            const cleanerLevel = gameState.tools.cleaner;
            const reduction = cleanerLevel > 1 ? gameState.traceLevel : Math.min(20, gameState.traceLevel);
            gameState.traceLevel = Math.max(0, gameState.traceLevel - reduction);
            addTerminalLine(cleanerLevel > 1 ? 
                '> Trace fully cleared using Trace Cleaner.' :
                `> Trace reduced by ${reduction}.`);
            updateDisplay();
            saveGame();
            enableInput();
        },
        description: 'Clear trace level'
    },
    status: {
        execute: () => {
            addTerminalLine('=== SYSTEM STATUS ===');
            addTerminalLine(`Credits: ${Math.floor(gameState.credits)}`);
            addTerminalLine(`Reputation: ${gameState.reputation}`);
            addTerminalLine(`Trace Level: ${Math.round(gameState.traceLevel)}%`);
            addTerminalLine(`Heat Level: ${Math.round(gameState.heat)}%`);
            addTerminalLine(`Rank: ${determineRank(gameState.reputation)}`);
            addTerminalLine(`Tools: Scanner (Lv${gameState.tools.scanner}), Cracker (Lv${gameState.tools.cracker}), Cleaner (Lv${gameState.tools.cleaner})`);
            enableInput();
        },
        description: 'Show current status'
    },
    targets: {
        execute: () => {
            addTerminalLine('=== AVAILABLE TARGETS ===');
            Object.values(targets).forEach(target => {
                addTerminalLine(`${target.name} (Difficulty: ${target.difficulty} | Reward: ${target.reward} credits)`);
            });
            enableInput();
        },
        description: 'List available targets'
    },
    clear: {
        execute: () => {
            terminalOutput.innerHTML = '';
            addTerminalLine('> Terminal cleared.');
            enableInput();
        },
        description: 'Clear terminal output'
    },
    upgrade: {
        execute: (tool) => {
            if (!tool) {
                addTerminalLine('Usage: upgrade [scanner|cracker|cleaner]');
                enableInput();
                return;
            }
            const costs = { scanner: 200, cracker: 300, cleaner: 250 };
            if (!costs[tool]) {
                addTerminalLine('> Invalid tool.');
                enableInput();
                return;
            }
            const cost = costs[tool] * gameState.tools[tool];
            if (gameState.credits < cost) {
                addTerminalLine(`> Not enough credits. Cost: ${cost}`);
                enableInput();
                return;
            }
            gameState.credits -= cost;
            gameState.tools[tool]++;
            addTerminalLine(`> ${tool.toUpperCase()} upgraded to level ${gameState.tools[tool]}`);
            updateDisplay();
            saveGame();
            enableInput();
        },
        description: 'Upgrade a tool'
    },
    shop: {
        execute: () => {
            addTerminalLine('=== UPGRADE SHOP ===');
            addTerminalLine(`Scanner Upgrade: ${200 * gameState.tools.scanner} credits (Current: Level ${gameState.tools.scanner})`);
            addTerminalLine(`Cracker Upgrade: ${300 * gameState.tools.cracker} credits (Current: Level ${gameState.tools.cracker})`);
            addTerminalLine(`Cleaner Upgrade: ${250 * gameState.tools.cleaner} credits (Current: Level ${gameState.tools.cleaner})`);
            enableInput();
        },
        description: 'View available upgrades'
    },
    blackmarket: {
        execute: () => {
            addTerminalLine('=== BLACK MARKET ===');
            addTerminalLine('Available Tools:');
            Object.entries(blackMarketItems.tools).forEach(([name, item]) => {
                addTerminalLine(`${name}: ${item.cost} credits (${item.effect} +${(item.bonus * 100).toFixed(0)}%)`);
            });
            addTerminalLine('\nAvailable Mercenaries:');
            Object.entries(blackMarketItems.mercenaries).forEach(([name, merc]) => {
                addTerminalLine(`${name}: ${merc.cost} credits (${merc.skill} +${(merc.bonus * 100).toFixed(0)}%, ${merc.level}) - ${merc.description}`);
            });
            enableInput();
        },
        description: 'Access the black market'
    },
    buy: {
        execute: (item) => {
            const marketItem = blackMarketItems.tools[item];
            if (!marketItem) {
                addTerminalLine('> Item not found.');
                enableInput();
                return;
            }
            if (gameState.credits < marketItem.cost) {
                addTerminalLine(`> Not enough credits. Cost: ${marketItem.cost}`);
                enableInput();
                return;
            }
            gameState.credits -= marketItem.cost;
            gameState.tools[marketItem.effect] += marketItem.bonus;
            addTerminalLine(`> Purchased ${item}! ${marketItem.effect} upgraded.`);
            updateDisplay();
            saveGame();
            enableInput();
        },
        description: 'Purchase an item from black market'
    },
    hire: {
        execute: (args) => {
            const [type, ...nameParts] = args.trim().split(' ');
            const name = nameParts.join(' ');
            if (!type || !name || !['hacker', 'mercenary'].includes(type.toLowerCase())) {
                addTerminalLine('Usage: hire [hacker|mercenary] [name]');
                enableInput();
                return;
            }
            const personnel = blackMarketItems.mercenaries[name];
            if (!personnel) {
                addTerminalLine('> Personnel not found.');
                enableInput();
                return;
            }
            if (gameState.credits < personnel.cost) {
                addTerminalLine(`> Not enough credits. Cost: ${personnel.cost}`);
                enableInput();
                return;
            }
            gameState.credits -= personnel.cost;
            gameState.team[type + 's'].push({ name, ...personnel });
            addTerminalLine(`> Hired ${name}! (${personnel.level} ${personnel.skill})`);
            updateDisplay();
            saveGame();
            enableInput();
        },
        description: 'Hire a hacker or mercenary'
    },
    team: {
        execute: () => {
            addTerminalLine('=== YOUR TEAM ===');
            if (!gameState.team.hackers.length && !gameState.team.mercenaries.length) {
                addTerminalLine('No personnel hired.');
                enableInput();
                return;
            }
            if (gameState.team.hackers.length) {
                addTerminalLine('Hackers:');
                gameState.team.hackers.forEach(h => addTerminalLine(`- ${h.name} (${h.level} ${h.skill}, +${(h.bonus * 100).toFixed(0)}%)`));
            }
            if (gameState.team.mercenaries.length) {
                addTerminalLine('Mercenaries:');
                gameState.team.mercenaries.forEach(m => addTerminalLine(`- ${m.name} (${m.level} ${m.skill}, +${(m.bonus * 100).toFixed(0)}%)`));
            }
            enableInput();
        },
        description: 'View your current team'
    },
    list: {
        execute: (type) => {
            if (!['hackers', 'mercenaries'].includes(type)) {
                addTerminalLine('Usage: list [hackers|mercenaries]');
                enableInput();
                return;
            }
            addTerminalLine(`=== AVAILABLE ${type.toUpperCase()} ===`);
            Object.entries(blackMarketItems.mercenaries)
                .filter(([_, merc]) => type === 'hackers' ? merc.skill === 'cracker' : true)
                .forEach(([name, merc]) => {
                    addTerminalLine(`${name}: ${merc.cost} credits (${merc.skill} +${(merc.bonus * 100).toFixed(0)}%, ${merc.level}) - ${merc.description}`);
                });
            enableInput();
        },
        description: 'List available hackers or mercenaries'
    },
    fire: {
        execute: (args) => {
            const [type, ...nameParts] = args.trim().split(' ');
            const name = nameParts.join(' ');
            if (!type || !name || !['hacker', 'mercenary'].includes(type.toLowerCase())) {
                addTerminalLine('Usage: fire [hacker|mercenary] [name]');
                enableInput();
                return;
            }
            const team = gameState.team[type + 's'];
            const index = team.findIndex(p => p.name.toLowerCase() === name.toLowerCase());
            if (index === -1) {
                addTerminalLine(`> ${name} not found.`);
                enableInput();
                return;
            }
            team.splice(index, 1);
            addTerminalLine(`> Fired ${name}.`);
            updateDisplay();
            saveGame();
            enableInput();
        },
        description: 'Fire a team member'
    },
    factions: {
        execute: () => {
            addTerminalLine('=== FACTION STATUS ===');
            Object.entries(gameState.factions).forEach(([faction, data]) => {
                addTerminalLine(`${faction.toUpperCase()}: ${data.reputation} reputation`);
                if (data.missions.length) {
                    addTerminalLine('Active Missions:');
                    data.missions.forEach(m => addTerminalLine(`- ${m.title} (${m.difficulty}, ${m.reward} credits)`));
                }
            });
            enableInput();
        },
        description: 'View faction status'
    },
    mission: {
        execute: (faction) => {
            if (!faction) {
                addTerminalLine('Usage: mission [faction]');
                enableInput();
                return;
            }
            const missions = factionMissions[faction.toLowerCase()];
            if (!missions) {
                addTerminalLine('> Faction not found.');
                enableInput();
                return;
            }
            addTerminalLine(`=== ${faction.toUpperCase()} MISSIONS ===`);
            missions.forEach(m => {
                addTerminalLine(`${m.id}: ${m.title} (Reward: ${m.reward} credits, Heat: +${m.heat}, ${m.difficulty})`);
            });
            enableInput();
        },
        description: 'View available missions for a faction'
    },
    accept: {
        execute: (missionId) => {
            if (!missionId) {
                addTerminalLine('Usage: accept [mission_id]');
                enableInput();
                return;
            }
            let mission = null;
            let faction = null;
            Object.entries(factionMissions).forEach(([f, missions]) => {
                const found = missions.find(m => m.id === missionId);
                if (found) {
                    mission = found;
                    faction = f;
                }
            });
            if (!mission) {
                addTerminalLine('> Mission not found.');
                enableInput();
                return;
            }
            if (gameState.factions[faction].missions.find(m => m.id === missionId)) {
                addTerminalLine('> Mission already accepted.');
                enableInput();
                return;
            }
            gameState.factions[faction].missions.push(mission);
            gameState.heat += mission.heat;
            addTerminalLine(`> Accepted mission: ${mission.title}`);
            updateDisplay();
            saveGame();
            enableInput();
        },
        description: 'Accept a faction mission'
    },
    heat: {
        execute: () => {
            addTerminalLine('=== HEAT STATUS ===');
            addTerminalLine(`Current Heat: ${Math.round(gameState.heat)}%`);
            addTerminalLine(`Wanted: ${gameState.wanted ? 'YES' : 'NO'}`);
            enableInput();
        },
        description: 'View heat status'
    },
    safehouse: {
        execute: () => {
            addTerminalLine('=== YOUR SAFEHOUSE ===');
            Object.entries(gameState.safehouse).forEach(([key, level]) => {
                const upgrade = safehouseUpgrades[key];
                addTerminalLine(`${upgrade.name}: Level ${level}`);
                if (upgrade.levels[level]) {
                    addTerminalLine(`Next: ${upgrade.levels[level].effect} (Cost: ${upgrade.levels[level].cost} credits)`);
                } else {
                    addTerminalLine('Max level reached');
                }
            });
            enableInput();
        },
        description: 'View safehouse status and upgrades'
    },
    upgrade_safehouse: {
        execute: (upgradeName) => {
            if (!upgradeName) {
                addTerminalLine('Usage: upgrade_safehouse [scannerRoom|firewallLab|cryptoMiner]');
                enableInput();
                return;
            }
            const upgrade = safehouseUpgrades[upgradeName];
            if (!upgrade) {
                addTerminalLine('> Invalid upgrade.');
                enableInput();
                return;
            }
            const level = gameState.safehouse[upgradeName];
            if (!upgrade.levels[level]) {
                addTerminalLine('> Max level reached.');
                enableInput();
                return;
            }
            if (gameState.credits < upgrade.levels[level].cost) {
                addTerminalLine(`> Not enough credits. Cost: ${upgrade.levels[level].cost}`);
                enableInput();
                return;
            }
            gameState.credits -= upgrade.levels[level].cost;
            gameState.safehouse[upgradeName]++;
            addTerminalLine(`> Upgraded ${upgrade.name} to Level ${gameState.safehouse[upgradeName]}`);
            if (upgradeName === 'cryptoMiner') {
                setupCryptoMiner();
            }
            updateDisplay();
            saveGame();
            enableInput();
        },
        description: 'Upgrade your safehouse'
    },
    crypto: {
        execute: () => {
            addTerminalLine('=== CRYPTO MARKET ===');
            Object.entries(cryptoMarketPrices).forEach(([crypto, price]) => {
                addTerminalLine(`${crypto}: ${price} credits/unit`);
            });
            addTerminalLine('\n=== YOUR HOLDINGS ===');
            Object.entries(gameState.cryptoHoldings).forEach(([crypto, amount]) => {
                addTerminalLine(`${crypto}: ${amount} units (Value: ${amount * cryptoMarketPrices[crypto]} credits)`);
            });
            enableInput();
        },
        description: 'View crypto market prices and holdings'
    },
    buy_crypto: {
        execute: (args) => {
            const [currency, amount] = args.trim().split(' ');
            if (!currency || !amount || isNaN(amount) || parseInt(amount) <= 0) {
                addTerminalLine('Usage: buy_crypto [bitghost|zerocoin] [amount]');
                enableInput();
                return;
            }
            const price = cryptoMarketPrices[currency.toLowerCase()];
            if (!price) {
                addTerminalLine('> Invalid currency.');
                enableInput();
                return;
            }
            const cost = price * parseInt(amount);
            if (gameState.credits < cost) {
                addTerminalLine(`> Not enough credits. Cost: ${cost}`);
                enableInput();
                return;
            }
            gameState.credits -= cost;
            gameState.cryptoHoldings[currency.toLowerCase()] += parseInt(amount);
            addTerminalLine(`> Bought ${amount} ${currency} for ${cost} credits.`);
            updateDisplay();
            saveGame();
            enableInput();
        },
        description: 'Buy cryptocurrency'
    },
    sell_crypto: {
        execute: (args) => {
            const [currency, amount] = args.trim().split(' ');
            if (!currency || !amount || isNaN(amount) || parseInt(amount) <= 0) {
                addTerminalLine('Usage: sell_crypto [bitghost|zerocoin] [amount]');
                enableInput();
                return;
            }
            const price = cryptoMarketPrices[currency.toLowerCase()];
            if (!price) {
                addTerminalLine('> Invalid currency.');
                enableInput();
                return;
            }
            if (gameState.cryptoHoldings[currency.toLowerCase()] < parseInt(amount)) {
                addTerminalLine('> Not enough holdings.');
                enableInput();
                return;
            }
            gameState.credits += price * parseInt(amount);
            gameState.cryptoHoldings[currency.toLowerCase()] -= parseInt(amount);
            addTerminalLine(`> Sold ${amount} ${currency} for ${price * parseInt(amount)} credits.`);
            updateDisplay();
            saveGame();
            enableInput();
        },
        description: 'Sell cryptocurrency'
    },
    set_prompt: {
        execute: (prompt) => {
            if (!prompt) {
                addTerminalLine('Usage: set_prompt [prompt]');
                enableInput();
                return;
            }
            const safePrompt = prompt.replace(/[<>]/g, '');
            gameState.customPrompt = safePrompt + ' ';
            addTerminalLine(`> Prompt set to: ${gameState.customPrompt}`);
            updateDisplay();
            saveGame();
            enableInput();
        },
        description: 'Set custom terminal prompt'
    },
    achievements: {
        execute: () => {
            addTerminalLine('=== ACHIEVEMENTS ===');
            if (!gameState.achievements.length) {
                addTerminalLine('No achievements unlocked.');
                enableInput();
                return;
            }
            gameState.achievements.forEach(a => addTerminalLine(`- ${a}`));
            enableInput();
        },
        description: 'View unlocked achievements'
    },
    matrix: {
        execute: () => {
            gameState.easterEggs.matrix = !gameState.easterEggs.matrix;
            ['matrix', 'monochrome', 'tron', 'inferno'].forEach(mode => {
                document.body.classList.remove(`${mode}-mode`);
                gameState.easterEggs[mode] = mode === 'matrix' ? gameState.easterEggs.matrix : false;
            });
            if (gameState.easterEggs.matrix) {
                document.body.classList.add('matrix-mode');
                addTerminalLine('> Matrix mode activated.');
            } else {
                addTerminalLine('> Matrix mode deactivated.');
            }
            updateDisplay();
            saveGame();
            enableInput();
        },
        description: 'Toggle Matrix-style visual effects'
    },
    monochrome: {
        execute: () => {
            gameState.easterEggs.monochrome = !gameState.easterEggs.monochrome;
            ['matrix', 'monochrome', 'tron', 'inferno'].forEach(mode => {
                document.body.classList.remove(`${mode}-mode`);
                gameState.easterEggs[mode] = mode === 'monochrome' ? gameState.easterEggs.monochrome : false;
            });
            if (gameState.easterEggs.monochrome) {
                document.body.classList.add('monochrome-mode');
                addTerminalLine('> Monochrome mode activated.');
            } else {
                addTerminalLine('> Monochrome mode deactivated.');
            }
            updateDisplay();
            saveGame();
            enableInput();
        },
        description: 'Toggle Monochrome visual effects'
    },
    tron: {
        execute: () => {
            gameState.easterEggs.tron = !gameState.easterEggs.tron;
            ['matrix', 'monochrome', 'tron', 'inferno'].forEach(mode => {
                document.body.classList.remove(`${mode}-mode`);
                gameState.easterEggs[mode] = mode === 'tron' ? gameState.easterEggs.tron : false;
            });
            if (gameState.easterEggs.tron) {
                document.body.classList.add('tron-mode');
                addTerminalLine('> Tron mode activated.');
            } else {
                addTerminalLine('> Tron mode deactivated.');
            }
            updateDisplay();
            saveGame();
            enableInput();
        },
        description: 'Toggle Tron-style visual effects'
    },
    inferno: {
        execute: () => {
            gameState.easterEggs.inferno = !gameState.easterEggs.inferno;
            ['matrix', 'monochrome', 'tron', 'inferno'].forEach(mode => {
                document.body.classList.remove(`${mode}-mode`);
                gameState.easterEggs[mode] = mode === 'inferno' ? gameState.easterEggs.inferno : false;
            });
            if (gameState.easterEggs.inferno) {
                document.body.classList.add('inferno-mode');
                addTerminalLine('> Inferno mode activated.');
            } else {
                addTerminalLine('> Inferno mode deactivated.');
            }
            updateDisplay();
            saveGame();
            enableInput();
        },
        description: 'Toggle Inferno visual effects'
    },
    hackerman: {
        execute: () => {
            if (gameState.reputation >= 1000) {
                gameState.easterEggs.hackerman = true;
                addTerminalLine('> You are now a true hackerman!');
                if (!gameState.achievements.includes('Hackerman Status')) {
                    gameState.achievements.push('Hackerman Status');
                    addTerminalLine('> Achievement unlocked: Hackerman Status!');
                }
            } else {
                addTerminalLine(`> Requires 1000+ reputation. Current: ${gameState.reputation}`);
            }
            updateDisplay();
            saveGame();
            enableInput();
        },
        description: 'Special command for high-reputation players'
    },
    save: {
        execute: () => {
            saveGame();
            addTerminalLine('> Game state saved.');
            enableInput();
        },
        description: 'Save current game state'
    },
    load: {
        execute: () => {
            loadGame();
            addTerminalLine('> Game state loaded.');
            enableInput();
        },
        description: 'Load last saved game state'
    }
};

// Save game state
function saveGame() {
    try {
        gameState.lastSave = Date.now();
        const gameData = JSON.stringify(gameState);
        if (gameData.length > 5000000) { // 5MB limit check
            throw new Error('Save file too large');
        }
        localStorage.setItem('nexusSave', gameData);
    } catch (e) {
        console.error('Error saving game:', e);
        addTerminalLine('> Error: Failed to save game. Storage may be full or restricted.');
    }
}

// Helper function to find target key by name
function findTargetKeyByName(name) {
    return Object.keys(targets).find(key => 
        targets[key].name.toLowerCase().replace(/\s/g, '') === name.toLowerCase().replace(/\s/g, '')
    ) || null;
}

// Process command
function processCommand(input) {
    if (!input || gameState.commandEntered) return;
    
    try {
        gameState.commandEntered = true;
        commandInput.disabled = true;
        addTerminalLine(`${gameState.customPrompt}${input}`);
        gameState.commandHistory.push(input);
        gameState.historyIndex = -1;
        
        const [command, ...args] = input.trim().split(/\s+/);
        if (commands[command.toLowerCase()]) {
            commands[command.toLowerCase()].execute(args.join(' '));
        } else {
            addTerminalLine('> Command not recognized. Type "help" for commands.');
            enableInput();
        }
    } catch (e) {
        console.error('Error processing command:', e);
        addTerminalLine('> Error: Command processing failed.');
        enableInput();
    }
}

// Enable input after command processing
function enableInput() {
    try {
        gameState.commandEntered = false;
        if (commandInput) {
            commandInput.disabled = false;
            commandInput.focus();
        }
    } catch (e) {
        console.error('Error enabling input:', e);
    }
}

// Command input handler
let debounceTimeout;
function handleCommandInput(e) {
    try {
        if (e.key === 'Enter') {
            clearTimeout(debounceTimeout);
            debounceTimeout = setTimeout(() => {
                const command = commandInput.value.trim();
                if (command && !gameState.commandEntered) {
                    processCommand(command);
                }
                commandInput.value = '';
                historyIndex = -1;
            }, 100);
        } else if (e.key === 'Tab') {
            e.preventDefault();
            const input = commandInput.value.trim();
            const suggestions = getCommandSuggestions(input);
            if (suggestions.length === 1) {
                const parts = input.split(/\s+/);
                parts[parts.length - 1] = suggestions[0];
                commandInput.value = parts.join(' ');
            } else if (suggestions.length > 1) {
                addTerminalLine('> Available completions:');
                suggestions.forEach(s => addTerminalLine(`- ${s}`));
            }
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            if (historyIndex < gameState.commandHistory.length - 1) {
                historyIndex++;
                commandInput.value = gameState.commandHistory[gameState.commandHistory.length - 1 - historyIndex];
            }
        } else if (e.key === 'ArrowDown') {
            e.preventDefault();
            if (historyIndex > -1) {
                historyIndex--;
                commandInput.value = historyIndex === -1 ? '' : gameState.commandHistory[gameState.commandHistory.length - 1 - historyIndex];
            }
        }
    } catch (e) {
        console.error('Error handling command input:', e);
    }
}

// Add event listeners safely
function initializeEventListeners() {
    try {
        if (commandInput) {
            commandInput.addEventListener('keydown', handleCommandInput);
        }
        if (scrollBtn) {
            scrollBtn.addEventListener('click', scrollToBottom);
        }
        window.addEventListener('beforeunload', () => {
            saveGame();
            if (binaryStreamInterval) clearInterval(binaryStreamInterval);
            if (gameState.safehouse.cryptoMinerTimer) clearInterval(gameState.safehouse.cryptoMinerTimer);
        });
    } catch (e) {
        console.error('Error initializing event listeners:', e);
    }
}

// Initialize the game
try {
    setTimeout(() => {
        bootScreen.style.display = 'none';
        addTerminalLine('> Welcome back, operator.');
        addTerminalLine('> NEXUS interface fully loaded.');
        loadGame();
        initializeEventListeners();
        if (commandInput) commandInput.focus();
    }, 3000);
} catch (e) {
    console.error('Error initializing game:', e);
}

// Minigame logic
function startMinigame(targetKey) {
    if (!targets[targetKey]) {
        addTerminalLine('> Invalid target.');
        enableInput();
        return;
    }
    const target = targets[targetKey];
    const minigameTitle = document.getElementById('minigame-title');
    const minigameContent = document.getElementById('minigame-content');
    
    if (!minigameTitle || !minigameContent) {
        addTerminalLine('> Error: Minigame interface not properly initialized.');
        enableInput();
        return;
    }
    
    minigameTitle.textContent = `HACKING: ${target.name}`;
    let puzzleHTML = '';
    
    switch (targetKey) {
        case 'gameserver':
            puzzleHTML = `
                <div class="password-challenge">
                    <div class="password-hint">SECURITY PATTERN DETECTED</div>
                    <div class="puzzle-visual">${target.pattern}</div>
                    <div class="password-hint">${target.hint}</div>
                    <input type="text" class="password-input" id="password-input" placeholder="Enter the complete word...">
                    <button class="btn" onclick="checkPassword(document.getElementById('password-input').value, '${targetKey}')">DECRYPT</button>
                    <button class="btn" onclick="closeMinigame()">ABORT</button>
                </div>
            `;
            break;
        case 'socialnet':
            puzzleHTML = `
                <div class="password-challenge">
                    <div class="password-hint">ENCRYPTED ACCESS CODE FOUND</div>
                    <div class="puzzle-visual"><div class="cipher-text">${target.cipher}</div></div>
                    <div class="password-hint">${target.hint}</div>
                    <input type="text" class="password-input" id="password-input" placeholder="Enter decrypted word...">
                    <button class="btn" onclick="checkPassword(document.getElementById('password-input').value, '${targetKey}')">DECRYPT</button>
                    <button class="btn" onclick="closeMinigame()">ABORT</button>
                </div>
            `;
            break;
        case 'corpnet':
            puzzleHTML = `
                <div class="password-challenge">
                    <div class="password-hint">KEYPAD SEQUENCE DETECTED</div>
                    <div class="keypad-visual">
                        <div class="key">1<br>ABC</div>
                        <div class="key">2<br>DEF</div>
                        <div class="key">3<br>GHI</div>
                        <div class="key highlight">4<br>JKL</div>
                        <div class="key">5<br>MNO</div>
                        <div class="key">6<br>PQR</div>
                        <div class="key highlight">7<br>STU</div>
                        <div class="key">8<br>VWX</div>
                        <div class="key highlight">9<br>YZ</div>
                    </div>
                    <div class="password-hint">${target.hint}</div>
                    <input type="text" class="password-input" id="password-input" placeholder="What word do the highlighted keys spell?">
                    <button class="btn" onclick="checkPassword(document.getElementById('password-input').value, '${targetKey}')">DECRYPT</button>
                    <button class="btn" onclick="closeMinigame()">ABORT</button>
                </div>
            `;
            break;
        case 'quantum':
            puzzleHTML = `
                <div class="password-challenge">
                    <div class="password-hint">ALIGN THE FLUCTUATING QUBITS</div>
                    <div id="quantum-qubits" style="display: flex; justify-content: center; gap: 10px; margin: 20px 0;"></div>
                    <div class="password-hint">${target.hint}</div>
                    <button class="btn" onclick="checkPassword('', '${targetKey}')">DECODE</button>
                    <button class="btn" onclick="closeMinigame()">ABORT</button>
                </div>
            `;
            break;
        case 'ai_core':
            puzzleHTML = `
                <div class="password-challenge">
                    <div class="password-hint">SYNCHRONIZE WITH THE BINARY STREAM</div>
                    <div id="binary-stream" style="font-size: 24px; text-align: center; margin: 20px 0; overflow: hidden; white-space: nowrap;"></div>
                    <div class="password-hint">${target.hint}</div>
                    <input type="text" class="password-input" id="password-input" placeholder="Enter captured pattern...">
                    <button class="btn" onclick="checkPassword(document.getElementById('password-input').value, '${targetKey}')">SUBMIT</button>
                    <button class="btn" onclick="closeMinigame()">ABORT</button>
                </div>
            `;
            break;
    }
    
    minigameContent.innerHTML = puzzleHTML;
    minigameOverlay.style.display = 'flex';
    
    if (targetKey === 'quantum') setupQuantumPuzzle(target);
    if (targetKey === 'ai_core') setupBinaryPuzzle(target);
    
    requestAnimationFrame(() => {
        const input = document.getElementById('password-input');
        if (input) input.focus();
    });
}

function checkPassword(input, targetKey) {
    const target = targets[targetKey];
    if (!target) {
        addTerminalLine('> Error: Invalid target.');
        closeMinigame();
        return;
    }
    
    if (targetKey === 'quantum') {
        const isCorrect = quantumState.every((state, i) => state === targetQuantumState[i]);
        if (isCorrect) {
            hackSuccess(target);
        } else {
            hackFailure(target);
        }
    } else if (targetKey === 'ai_core') {
        if (input.toLowerCase() === targetBinaryPattern.toLowerCase()) {
            hackSuccess(target);
        } else {
            hackFailure(target);
        }
    } else if (input.toLowerCase() === target.password.toLowerCase()) {
        hackSuccess(target);
    } else {
        hackFailure(target);
    }
}

let quantumState = [];
let targetQuantumState = [];

function setupQuantumPuzzle(target) {
    const qubitsContainer = document.getElementById('quantum-qubits');
    if (!qubitsContainer) return;
    
    const password = target.password;
    quantumState = Array(password.length).fill(0);
    targetQuantumState = password.split('').map(char => char.charCodeAt(0) % 2);
    qubitsContainer.innerHTML = '';
    
    for (let i = 0; i < password.length; i++) {
        const qubit = document.createElement('div');
        qubit.className = 'qubit';
        qubit.style.cssText = `
            width: 30px; 
            height: 30px; 
            background: ${quantumState[i] ? 'var(--primary-color)' : 'var(--stat-bar-bg)'}; 
            border: 1px solid var(--primary-color); 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            cursor: pointer;
            color: ${quantumState[i] ? 'var(--btn-hover-text)' : 'var(--primary-color)'};
        `;
        qubit.textContent = quantumState[i] ? '1' : '0';
        qubit.dataset.index = i;
        qubit.onclick = toggleQubit;
        qubitsContainer.appendChild(qubit);
    }
}

function toggleQubit(event) {
    const index = parseInt(event.target.dataset.index);
    quantumState[index] = 1 - quantumState[index];
    event.target.textContent = quantumState[index] ? '1' : '0';
    event.target.style.background = quantumState[index] ? 'var(--primary-color)' : 'var(--stat-bar-bg)';
    event.target.style.color = quantumState[index] ? 'var(--btn-hover-text)' : 'var(--primary-color)';
}

let binaryStreamInterval;
let binarySequence = '';
let targetBinaryPattern = '';

function setupBinaryPuzzle(target) {
    const streamElement = document.getElementById('binary-stream');
    if (!streamElement) return;
    
    targetBinaryPattern = target.password;
    binarySequence = Array(200).fill(0)
        .map(() => Math.random() > 0.5 ? '1' : '0')
        .join('');
    
    // Insert target pattern at random position
    const insertPos = Math.floor(Math.random() * (binarySequence.length - targetBinaryPattern.length));
    binarySequence = binarySequence.substring(0, insertPos) + 
                     targetBinaryPattern + 
                     binarySequence.substring(insertPos + targetBinaryPattern.length);
    
    let streamPosition = 0;
    clearInterval(binaryStreamInterval);
    binaryStreamInterval = setInterval(() => {
        streamElement.textContent = binarySequence.substring(streamPosition, streamPosition + 30);
        streamPosition = (streamPosition + 1) % (binarySequence.length - 30);
    }, 100);
}

function hackSuccess(target) {
    if (!gameState.currentTarget || !target) {
        addTerminalLine('> Error: Invalid target.');
        closeMinigame();
        return;
    }
    const teamBonus = gameState.team.hackers.reduce((sum, h) => sum + (h.skill === 'cracker' ? h.bonus : 0), 0) +
                      gameState.team.mercenaries.reduce((sum, m) => sum + (m.skill === 'cracker' ? m.bonus : 0), 0);
    const reward = Math.round(target.reward * (1 + teamBonus));
    const traceIncrease = Math.round({ 
        Easy: 5, 
        Medium: 10, 
        Hard: 15, 
        Expert: 25, 
        Master: 40 
    }[target.difficulty] * (1 - gameState.safehouse.firewallLab * 0.05));
    
    addTerminalLine(`> Access granted to ${target.name}.`);
    gameState.credits += reward;
    gameState.reputation += Math.floor(reward / 10);
    gameState.traceLevel += traceIncrease;
    gameState.heat += Math.round(traceIncrease * 0.5);
    
    if (!gameState.achievements.includes(`${target.difficulty} Hacker`)) {
        gameState.achievements.push(`${target.difficulty} Hacker`);
        addTerminalLine(`> Achievement unlocked: ${target.difficulty} Hacker`);
    }
    
    updateDisplay();
    saveGame();
    closeMinigame();
}

function hackFailure(target) {
    if (!gameState.currentTarget || !target) {
        addTerminalLine('> Error: Invalid target.');
        closeMinigame();
        return;
    }
    const traceIncrease = Math.round({ 
        Easy: 2, 
        Medium: 5, 
        Hard: 10, 
        Expert: 15, 
        Master: 20 
    }[target.difficulty] * (1 - gameState.safehouse.firewallLab * 0.05));
    
    addTerminalLine('> Access denied.');
    gameState.traceLevel += traceIncrease;
    gameState.heat += Math.round(traceIncrease * 0.5);
    updateDisplay();
    saveGame();
    closeMinigame();
}

function closeMinigame() {
    clearInterval(binaryStreamInterval);
    if (minigameOverlay) {
        minigameOverlay.style.display = 'none';
    }
    gameState.currentTarget = null;
    enableInput();
}

// Event listeners
scrollBtn.addEventListener('click', scrollToBottom);

// Cleanup on window unload
window.addEventListener('beforeunload', () => {
    saveGame();
    clearInterval(binaryStreamInterval);
    clearInterval(gameState.safehouse.cryptoMinerTimer);
});

// Initialize game
updateDisplay();    </script>
</body>
</html>
